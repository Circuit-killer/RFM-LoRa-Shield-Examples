{
    "docs": [
        {
            "location": "/", 
            "text": "Getting Started\n\n\nThis is an example tutorial of point-to-point wireless communication between 2 Arduinos using Cytron RFM LoRa Shields.\n\n\n\n\nImportant !!\n\n\nThis tutorial requires 2 Cytron RFM LoRa Shields.\n\n\n\n\nOverview\n\n\n\n\nBasic Requirements\n\n\nHardware Setup\n\n\nLibrary Installation\n\n\nUploading Sketches\n\n\nArduino Sketches Overview\n\n\nScreenshots\n\n\n\n\nBasic Requirements\n\n\n\n\n2 \nCytron RFM LoRa Shields\n\n\n2 Arduino-compatible boards\n\n\nUSB cable/accessories to upload Arduino program\n\n\nArduino IDE software\n\n\n\n\nHardware Setup\n\n\n\n\nStack Cytron RFM LoRa Shield onto Arduino compatible board with antenna installed as shown in picture below. In this case we are using \nCT-UNO\n.\n\n\nPrepare \n2\n sets for this.\n\n\n\n\nPictures\n\n\nCT-UNO with LoRa Shield on top\n\n\nCT-UNO with LoRa Shield and antenna installed\n\n\nLibrary Installation\n\n\n\n\nDownload the zip file from \nhere\n.\n\n\nOpen Arduino IDE, go to \nSketch \n Include Library \n Add .ZIP Library\n, choose the downloaded zip file and click Open.\n\n\n\n\nUploading Sketches\n\n\n\n\nDownload the Arduino sketches as zip files \nOR\n git clone this repo from \nhere\n.\n\n\nGrab one set of RFM LoRa Shield + Arduino that you have setup just now. We call it as \nArduino LoRa Client\n.\n\n\nOpen and upload \nrf95_client.ino\n sketch to \nArduino LoRa Client\n.\n\n\nGrab another set of RFM LoRa Shield + Arduino that you have setup just now. We call it as \nArduino LoRa Server\n.\n\n\nOpen and upload \nrf95_server.ino\n sketch to \nArduino LoRa Server\n.\n\n\n\n\nArduino Sketches Overview\n\n\n\n\nRefer \nhere\n.\n\n\n\n\nScreenshots\n\n\n\n\nArduino LoRa Server\n\n\n\n\nArduino LoRa Client", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#getting-started", 
            "text": "This is an example tutorial of point-to-point wireless communication between 2 Arduinos using Cytron RFM LoRa Shields.   Important !!  This tutorial requires 2 Cytron RFM LoRa Shields.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#overview", 
            "text": "Basic Requirements  Hardware Setup  Library Installation  Uploading Sketches  Arduino Sketches Overview  Screenshots", 
            "title": "Overview"
        }, 
        {
            "location": "/#basic-requirements", 
            "text": "2  Cytron RFM LoRa Shields  2 Arduino-compatible boards  USB cable/accessories to upload Arduino program  Arduino IDE software", 
            "title": "Basic Requirements"
        }, 
        {
            "location": "/#hardware-setup", 
            "text": "Stack Cytron RFM LoRa Shield onto Arduino compatible board with antenna installed as shown in picture below. In this case we are using  CT-UNO .  Prepare  2  sets for this.", 
            "title": "Hardware Setup"
        }, 
        {
            "location": "/#pictures", 
            "text": "CT-UNO with LoRa Shield on top  CT-UNO with LoRa Shield and antenna installed", 
            "title": "Pictures"
        }, 
        {
            "location": "/#library-installation", 
            "text": "Download the zip file from  here .  Open Arduino IDE, go to  Sketch   Include Library   Add .ZIP Library , choose the downloaded zip file and click Open.", 
            "title": "Library Installation"
        }, 
        {
            "location": "/#uploading-sketches", 
            "text": "Download the Arduino sketches as zip files  OR  git clone this repo from  here .  Grab one set of RFM LoRa Shield + Arduino that you have setup just now. We call it as  Arduino LoRa Client .  Open and upload  rf95_client.ino  sketch to  Arduino LoRa Client .  Grab another set of RFM LoRa Shield + Arduino that you have setup just now. We call it as  Arduino LoRa Server .  Open and upload  rf95_server.ino  sketch to  Arduino LoRa Server .", 
            "title": "Uploading Sketches"
        }, 
        {
            "location": "/#arduino-sketches-overview", 
            "text": "Refer  here .", 
            "title": "Arduino Sketches Overview"
        }, 
        {
            "location": "/#screenshots", 
            "text": "Arduino LoRa Server   Arduino LoRa Client", 
            "title": "Screenshots"
        }, 
        {
            "location": "/Arduino-Sketches-Overview/", 
            "text": "Arduino Sketches Overview\n\n\nrf95_client.ino\n\n\n// LoRa 9x_TX\n\n\n// -*- mode: C++ -*-\n\n\n// Example sketch showing how to create a simple messaging client (transmitter)\n\n\n// with the RH_RF95 class. RH_RF95 class does not provide for addressing or\n\n\n// reliability, so you should only use RH_RF95 if you do not need the higher\n\n\n// level messaging abilities.\n\n\n// It is designed to work with the other example LoRa9x_RX\n\n\n\n#include\n \nSPI.h\n\n\n#include\n \nRH_RF95.h\n\n\n\n#define RFM95_CS 10\n\n\n#define RFM95_RST 7\n\n\n#define RFM95_INT 2\n\n\n#define node_id \nB\n\n\n\n// Change to 434.0 or other frequency, must match RX\ns freq!\n\n\n#define RF95_FREQ 915.0\n\n\n\n// Singleton instance of the radio driver\n\n\nRH_RF95\n \nrf95\n(\nRFM95_CS\n,\n \nRFM95_INT\n);\n\n\n\nvoid\n \nsetup\n()\n \n\n{\n\n  \npinMode\n(\nRFM95_RST\n,\n \nOUTPUT\n);\n\n  \ndigitalWrite\n(\nRFM95_RST\n,\n \nHIGH\n);\n\n\n  \nwhile\n \n(\n!\nSerial\n);\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n  \ndelay\n(\n100\n);\n\n\n  \nSerial\n.\nprintln\n(\nArduino LoRa TX Test!\n);\n\n\n  \n// manual reset\n\n  \ndigitalWrite\n(\nRFM95_RST\n,\n \nLOW\n);\n\n  \ndelay\n(\n10\n);\n\n  \ndigitalWrite\n(\nRFM95_RST\n,\n \nHIGH\n);\n\n  \ndelay\n(\n10\n);\n\n\n  \nwhile\n \n(\n!\nrf95\n.\ninit\n())\n \n{\n\n    \nSerial\n.\nprintln\n(\nLoRa radio init failed\n);\n\n    \nwhile\n \n(\n1\n);\n\n  \n}\n\n  \nSerial\n.\nprintln\n(\nLoRa radio init OK!\n);\n\n\n  \n// Defaults after init are 434.0MHz, modulation GFSK_Rb250Fd250, +13dbM\n\n  \nif\n \n(\n!\nrf95\n.\nsetFrequency\n(\nRF95_FREQ\n))\n \n{\n\n    \nSerial\n.\nprintln\n(\nsetFrequency failed\n);\n\n    \nwhile\n \n(\n1\n);\n\n  \n}\n\n  \nSerial\n.\nprint\n(\nSet Freq to: \n);\n \nSerial\n.\nprintln\n(\nRF95_FREQ\n);\n\n\n  \n// Defaults after init are 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on\n\n\n  \n// The default transmitter power is 13dBm, using PA_BOOST.\n\n  \n// If you are using RFM95/96/97/98 modules which uses the PA_BOOST transmitter pin, then \n\n  \n// you can set transmitter powers from 5 to 23 dBm:\n\n  \nrf95\n.\nsetTxPower\n(\n23\n,\n \nfalse\n);\n\n\n}\n\n\n\nint16_t\n \npacketnum\n \n=\n \n0\n;\n  \n// packet counter, we increment per xmission\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nSerial\n.\nprintln\n(\nSending to rf95_server\n);\n\n  \n// Send a message to rf95_server\n\n\n  \nString\n \nradiopacket\n \n=\n \nHello World #\n;\n\n  \nradiopacket\n \n+=\n \nString\n(\npacketnum\n++\n);\n\n  \nradiopacket\n \n+=\n \n from \n;\n\n  \nradiopacket\n \n+=\n \nnode_id\n;\n\n\n  \nSerial\n.\nprint\n(\nSending \n);\n \nSerial\n.\nprintln\n(\nradiopacket\n);\n \ndelay\n(\n10\n);\n\n  \nrf95\n.\nsend\n((\nuint8_t\n*\n)\nradiopacket\n.\nc_str\n(),\n \nradiopacket\n.\nlength\n()\n+\n1\n);\n\n\n  \nSerial\n.\nprintln\n(\nWaiting for packet to complete...\n);\n \ndelay\n(\n10\n);\n\n  \nrf95\n.\nwaitPacketSent\n();\n\n  \n// Now wait for a reply\n\n  \nuint8_t\n \nbuf\n[\nRH_RF95_MAX_MESSAGE_LEN\n];\n\n  \nuint8_t\n \nlen\n \n=\n \nsizeof\n(\nbuf\n);\n\n\n  \nSerial\n.\nprintln\n(\nWaiting for reply...\n);\n \n  \ndelay\n(\n10\n);\n\n  \nif\n \n(\nrf95\n.\nwaitAvailableTimeout\n(\n1000\n))\n\n  \n{\n \n    \n// Should be a reply message for us now   \n\n    \nif\n \n(\nrf95\n.\nrecv\n(\nbuf\n,\n \nlen\n))\n\n   \n{\n\n      \nSerial\n.\nprint\n(\nGot reply: \n);\n\n      \nSerial\n.\nprintln\n((\nchar\n*\n)\nbuf\n);\n\n      \nSerial\n.\nprint\n(\nRSSI: \n);\n\n      \nSerial\n.\nprintln\n(\nrf95\n.\nlastRssi\n(),\n \nDEC\n);\n    \n    \n}\n\n    \nelse\n\n    \n{\n\n      \nSerial\n.\nprintln\n(\nReceive failed\n);\n\n    \n}\n\n  \n}\n\n  \nelse\n\n  \n{\n\n    \nSerial\n.\nprintln\n(\nNo reply, is there a listener around?\n);\n\n  \n}\n\n  \ndelay\n(\n10000\n);\n \n\n}\n\n\n\n\n\n\nrf95_server.ino\n\n\n// Arduino9x_RX\n\n\n// -*- mode: C++ -*-\n\n\n// Example sketch showing how to create a simple messaging client (receiver)\n\n\n// with the RH_RF95 class. RH_RF95 class does not provide for addressing or\n\n\n// reliability, so you should only use RH_RF95 if you do not need the higher\n\n\n// level messaging abilities.\n\n\n// It is designed to work with the other example Arduino9x_TX\n\n\n\n#include\n \nSPI.h\n\n\n#include\n \nRH_RF95.h\n\n\n\n#define RFM95_CS 10\n\n\n#define RFM95_RST 7\n\n\n#define RFM95_INT 2\n\n\n\n// Change to 434.0 or other frequency, must match RX\ns freq!\n\n\n#define RF95_FREQ 915.0\n\n\n\n// Singleton instance of the radio driver\n\n\nRH_RF95\n \nrf95\n(\nRFM95_CS\n,\n \nRFM95_INT\n);\n\n\n\nvoid\n \nsetup\n()\n \n\n{\n   \n  \npinMode\n(\nRFM95_RST\n,\n \nOUTPUT\n);\n\n  \ndigitalWrite\n(\nRFM95_RST\n,\n \nHIGH\n);\n\n\n  \nwhile\n \n(\n!\nSerial\n);\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n  \ndelay\n(\n100\n);\n\n\n  \nSerial\n.\nprintln\n(\nArduino LoRa RX Test!\n);\n\n\n  \n// manual reset\n\n  \ndigitalWrite\n(\nRFM95_RST\n,\n \nLOW\n);\n\n  \ndelay\n(\n10\n);\n\n  \ndigitalWrite\n(\nRFM95_RST\n,\n \nHIGH\n);\n\n  \ndelay\n(\n10\n);\n\n\n  \nwhile\n \n(\n!\nrf95\n.\ninit\n())\n \n{\n\n    \nSerial\n.\nprintln\n(\nLoRa radio init failed\n);\n\n    \nwhile\n \n(\n1\n);\n\n  \n}\n\n  \nSerial\n.\nprintln\n(\nLoRa radio init OK!\n);\n\n\n  \n// Defaults after init are 434.0MHz, modulation GFSK_Rb250Fd250, +13dbM\n\n  \nif\n \n(\n!\nrf95\n.\nsetFrequency\n(\nRF95_FREQ\n))\n \n{\n\n    \nSerial\n.\nprintln\n(\nsetFrequency failed\n);\n\n    \nwhile\n \n(\n1\n);\n\n  \n}\n\n  \nSerial\n.\nprint\n(\nSet Freq to: \n);\n \nSerial\n.\nprintln\n(\nRF95_FREQ\n);\n\n\n  \n// Defaults after init are 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on\n\n\n  \n// The default transmitter power is 13dBm, using PA_BOOST.\n\n  \n// If you are using RFM95/96/97/98 modules which uses the PA_BOOST transmitter pin, then \n\n  \n// you can set transmitter powers from 5 to 23 dBm:\n\n  \nrf95\n.\nsetTxPower\n(\n23\n,\n \nfalse\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nif\n \n(\nrf95\n.\navailable\n())\n\n  \n{\n\n    \n// Should be a message for us now   \n\n    \nuint8_t\n \nbuf\n[\nRH_RF95_MAX_MESSAGE_LEN\n];\n\n    \nuint8_t\n \nlen\n \n=\n \nsizeof\n(\nbuf\n);\n\n\n    \nif\n \n(\nrf95\n.\nrecv\n(\nbuf\n,\n \nlen\n))\n\n    \n{\n\n      \nRH_RF95\n::\nprintBuffer\n(\nReceived: \n,\n \nbuf\n,\n \nlen\n);\n\n      \nSerial\n.\nprint\n(\nGot: \n);\n\n      \nSerial\n.\nprintln\n((\nchar\n*\n)\nbuf\n);\n\n       \nSerial\n.\nprint\n(\nRSSI: \n);\n\n      \nSerial\n.\nprintln\n(\nrf95\n.\nlastRssi\n(),\n \nDEC\n);\n\n\n      \n// Send a reply\n\n      \nuint8_t\n \ndata\n[]\n \n=\n \nAnd hello back to you\n;\n\n      \nrf95\n.\nsend\n(\ndata\n,\n \nsizeof\n(\ndata\n));\n\n      \nrf95\n.\nwaitPacketSent\n();\n\n      \nSerial\n.\nprintln\n(\nSent a reply\n);\n\n    \n}\n\n    \nelse\n\n    \n{\n\n      \nSerial\n.\nprintln\n(\nReceive failed\n);\n\n    \n}\n\n  \n}\n\n\n}", 
            "title": "Arduino Sketches Overview"
        }, 
        {
            "location": "/Arduino-Sketches-Overview/#arduino-sketches-overview", 
            "text": "", 
            "title": "Arduino Sketches Overview"
        }, 
        {
            "location": "/Arduino-Sketches-Overview/#rf95_clientino", 
            "text": "// LoRa 9x_TX  // -*- mode: C++ -*-  // Example sketch showing how to create a simple messaging client (transmitter)  // with the RH_RF95 class. RH_RF95 class does not provide for addressing or  // reliability, so you should only use RH_RF95 if you do not need the higher  // level messaging abilities.  // It is designed to work with the other example LoRa9x_RX  #include   SPI.h  #include   RH_RF95.h  #define RFM95_CS 10  #define RFM95_RST 7  #define RFM95_INT 2  #define node_id  B  // Change to 434.0 or other frequency, must match RX s freq!  #define RF95_FREQ 915.0  // Singleton instance of the radio driver  RH_RF95   rf95 ( RFM95_CS ,   RFM95_INT );  void   setup ()   { \n   pinMode ( RFM95_RST ,   OUTPUT ); \n   digitalWrite ( RFM95_RST ,   HIGH ); \n\n   while   ( ! Serial ); \n   Serial . begin ( 9600 ); \n   delay ( 100 ); \n\n   Serial . println ( Arduino LoRa TX Test! ); \n\n   // manual reset \n   digitalWrite ( RFM95_RST ,   LOW ); \n   delay ( 10 ); \n   digitalWrite ( RFM95_RST ,   HIGH ); \n   delay ( 10 ); \n\n   while   ( ! rf95 . init ())   { \n     Serial . println ( LoRa radio init failed ); \n     while   ( 1 ); \n   } \n   Serial . println ( LoRa radio init OK! ); \n\n   // Defaults after init are 434.0MHz, modulation GFSK_Rb250Fd250, +13dbM \n   if   ( ! rf95 . setFrequency ( RF95_FREQ ))   { \n     Serial . println ( setFrequency failed ); \n     while   ( 1 ); \n   } \n   Serial . print ( Set Freq to:  );   Serial . println ( RF95_FREQ ); \n\n   // Defaults after init are 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on \n\n   // The default transmitter power is 13dBm, using PA_BOOST. \n   // If you are using RFM95/96/97/98 modules which uses the PA_BOOST transmitter pin, then  \n   // you can set transmitter powers from 5 to 23 dBm: \n   rf95 . setTxPower ( 23 ,   false );  }  int16_t   packetnum   =   0 ;    // packet counter, we increment per xmission  void   loop ()  { \n   Serial . println ( Sending to rf95_server ); \n   // Send a message to rf95_server \n\n   String   radiopacket   =   Hello World # ; \n   radiopacket   +=   String ( packetnum ++ ); \n   radiopacket   +=    from  ; \n   radiopacket   +=   node_id ; \n\n   Serial . print ( Sending  );   Serial . println ( radiopacket );   delay ( 10 ); \n   rf95 . send (( uint8_t * ) radiopacket . c_str (),   radiopacket . length () + 1 ); \n\n   Serial . println ( Waiting for packet to complete... );   delay ( 10 ); \n   rf95 . waitPacketSent (); \n   // Now wait for a reply \n   uint8_t   buf [ RH_RF95_MAX_MESSAGE_LEN ]; \n   uint8_t   len   =   sizeof ( buf ); \n\n   Serial . println ( Waiting for reply... );  \n   delay ( 10 ); \n   if   ( rf95 . waitAvailableTimeout ( 1000 )) \n   {  \n     // Should be a reply message for us now    \n     if   ( rf95 . recv ( buf ,   len )) \n    { \n       Serial . print ( Got reply:  ); \n       Serial . println (( char * ) buf ); \n       Serial . print ( RSSI:  ); \n       Serial . println ( rf95 . lastRssi (),   DEC );     \n     } \n     else \n     { \n       Serial . println ( Receive failed ); \n     } \n   } \n   else \n   { \n     Serial . println ( No reply, is there a listener around? ); \n   } \n   delay ( 10000 );   }", 
            "title": "rf95_client.ino"
        }, 
        {
            "location": "/Arduino-Sketches-Overview/#rf95_serverino", 
            "text": "// Arduino9x_RX  // -*- mode: C++ -*-  // Example sketch showing how to create a simple messaging client (receiver)  // with the RH_RF95 class. RH_RF95 class does not provide for addressing or  // reliability, so you should only use RH_RF95 if you do not need the higher  // level messaging abilities.  // It is designed to work with the other example Arduino9x_TX  #include   SPI.h  #include   RH_RF95.h  #define RFM95_CS 10  #define RFM95_RST 7  #define RFM95_INT 2  // Change to 434.0 or other frequency, must match RX s freq!  #define RF95_FREQ 915.0  // Singleton instance of the radio driver  RH_RF95   rf95 ( RFM95_CS ,   RFM95_INT );  void   setup ()   {    \n   pinMode ( RFM95_RST ,   OUTPUT ); \n   digitalWrite ( RFM95_RST ,   HIGH ); \n\n   while   ( ! Serial ); \n   Serial . begin ( 9600 ); \n   delay ( 100 ); \n\n   Serial . println ( Arduino LoRa RX Test! ); \n\n   // manual reset \n   digitalWrite ( RFM95_RST ,   LOW ); \n   delay ( 10 ); \n   digitalWrite ( RFM95_RST ,   HIGH ); \n   delay ( 10 ); \n\n   while   ( ! rf95 . init ())   { \n     Serial . println ( LoRa radio init failed ); \n     while   ( 1 ); \n   } \n   Serial . println ( LoRa radio init OK! ); \n\n   // Defaults after init are 434.0MHz, modulation GFSK_Rb250Fd250, +13dbM \n   if   ( ! rf95 . setFrequency ( RF95_FREQ ))   { \n     Serial . println ( setFrequency failed ); \n     while   ( 1 ); \n   } \n   Serial . print ( Set Freq to:  );   Serial . println ( RF95_FREQ ); \n\n   // Defaults after init are 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on \n\n   // The default transmitter power is 13dBm, using PA_BOOST. \n   // If you are using RFM95/96/97/98 modules which uses the PA_BOOST transmitter pin, then  \n   // you can set transmitter powers from 5 to 23 dBm: \n   rf95 . setTxPower ( 23 ,   false );  }  void   loop ()  { \n   if   ( rf95 . available ()) \n   { \n     // Should be a message for us now    \n     uint8_t   buf [ RH_RF95_MAX_MESSAGE_LEN ]; \n     uint8_t   len   =   sizeof ( buf ); \n\n     if   ( rf95 . recv ( buf ,   len )) \n     { \n       RH_RF95 :: printBuffer ( Received:  ,   buf ,   len ); \n       Serial . print ( Got:  ); \n       Serial . println (( char * ) buf ); \n        Serial . print ( RSSI:  ); \n       Serial . println ( rf95 . lastRssi (),   DEC ); \n\n       // Send a reply \n       uint8_t   data []   =   And hello back to you ; \n       rf95 . send ( data ,   sizeof ( data )); \n       rf95 . waitPacketSent (); \n       Serial . println ( Sent a reply ); \n     } \n     else \n     { \n       Serial . println ( Receive failed ); \n     } \n   }  }", 
            "title": "rf95_server.ino"
        }
    ]
}